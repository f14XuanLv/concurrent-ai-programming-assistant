
# 并发 AI 编程助手

## 背景

大型语言模型（LLM），如 Gemini 和 Claude，越来越多地被用于协助开发人员修改代码。然而，一个常见的瓶颈是这些模型通常按顺序处理对单个文件或一组文件的修改请求。即使单个提示请求更改多个文件，开发人员也常常需要等待 AI 完成所有修改后才能看到结果。这可能导致大量的等待时间和效率降低。

**并发 AI 编程助手**是一个基于 Web 的 IDE，旨在应对这一挑战。它采用两级 AI 策略：

1.  **一级 AI（全局分析 - 手动步骤）：** 用户使用一个强大的人工智能（例如 Claude-4-opus 或功能强大的 Gemini 模型）对代码库进行全局分析。用户向 AI 提供项目结构、相关文件内容及其高级需求。AI 的作用是识别跨多个文件所有必要的修改，并以特定的结构化格式输出这些指令，包括建议的并发操作数。
2.  **二级 AI（文件特定执行 - 由本应用自动执行）：** 用户将一级 AI 的结构化输出粘贴到此应用程序中。然后，应用程序解析这些指令，并对指定的 Gemini 模型（默认为 `gemini-2.5-flash-preview-04-17`，用户可配置）进行并发 API 调用，以并行执行每个文件的特定代码修改。本应用使用 `@google/genai` SDK 执行这些调用。

这种方法旨在通过并行化单个文件修改的执行，显著加快将 AI 建议的更改应用于代码库的过程。

## 功能特性

*   **项目上传：** 直接在浏览器中上传整个项目文件夹。
*   **交互式文件树：** 查看和导航项目的目录结构。
*   **文件内容查看器：**
    *   显示基于文本的文件内容。
    *   直接在编辑器面板中渲染常见的图像类型（PNG、JPEG、GIF、SVG）。
*   **一级 AI 提示助手：**
    *   协助为用户选择的一级 AI 生成结构化提示。
    *   自动包含项目的文件树和上传文件列表。
    *   提供一个模板，供用户添加其特定的修改需求。
*   **一级 AI 输出处理：**
    *   解析来自一级 AI 的结构化输出（包含线程数和每个文件的详细修改指令）。
*   **并发二级 AI 执行：**
    *   根据解析的指令和建议的线程数，使用 `@google/genai` SDK 对配置的 Gemini 模型进行并行 API 调用。
*   **内存中文件更新：** 将从二级 AI 收到的修改应用于浏览器内的文件表示。
*   **可配置设置（含优先级）：**
    *   **API 密钥：**
        1.  用户输入的密钥（在“设置”面板中）具有最高优先级。
        2.  如果用户字段为空，则会静默使用部署者提供的密钥（通过 `API_KEY` 环境变量，例如在 Vercel 中设置）。
        3.  如果两者都不可用，则在执行时提示用户。
    *   **API URL：**
        1.  部署者提供的 URL（通过 `API_URL` 环境变量）具有最高优先级。如果设置，则“设置”中的 API URL 输入字段将被隐藏。
        2.  如果没有部署者 URL，用户可以在“设置”中输入自定义 URL。
        3.  如果以上两者均未设置，则默认为 `https://generativelanguage.googleapis.com`。
        4.  **注意：** `@google/genai` SDK 主要使用标准的 Google API 端点。自定义 API URL 可能对 SDK 发送请求的目标位置影响有限或无效。
    *   **Gemini 模型名称：** 指定用于二级 AI 修改的 Gemini 模型（默认为 `gemini-2.5-flash-preview-04-17`）。
    *   **忽略的文件夹：** 指定要从一级提示中排除、在树中折叠显示并在二级修改中跳过的文件夹。
*   **实时状态栏：** 提供有关当前操作、进度和错误的反馈。
*   **路径自动修正：** 如果一级 AI 输出的文件路径不包含根项目文件夹名称，则尝试修正它们。

## 工作流程

1.  **设置 API 配置（设置面板）：**
    *   **Gemini API 密钥：** 您可以在此处输入您的 API 密钥。如果您将此字段留空，应用程序将尝试使用部署者提供的 API 密钥（如果通过 `API_KEY` 环境变量配置）。如果两者都不可用，当您尝试执行修改时，系统会提示您。
    *   **Gemini API URL：**
        *   如果部署者已配置 `API_URL` 环境变量，则此字段将被隐藏，并使用部署者的 URL。
        *   否则，此字段可见。您可以输入自己的 API URL，或将其留空以使用默认值 (`https://generativelanguage.googleapis.com`)。
        *   **重要 SDK 说明：** 本应用使用 `@google/genai` SDK, 该 SDK 通常管理其自己的 API 端点。此处输入的自定义 URL 可能不会改变 SDK 的目标端点。
    *   可选地，设置 **Gemini 模型名称**。
    *   可选地，自定义**忽略的文件夹**列表。
2.  **上传项目：** 点击“上传项目文件夹”按钮。
3.  **准备一级 AI 提示（一级面板 - 步骤 1）：**
    *   在“您的需求”文本区域中描述您的高级需求。
    *   点击“准备/刷新一级提示模板”按钮。
    *   查看并编辑生成的提示。
4.  **使用外部一级 AI（手动步骤）：**
    *   复制一级提示。
    *   将其粘贴到您选择的强大 LLM 中，并获取结构化响应。
5.  **处理一级 AI 输出（一级面板 - 步骤 2）：**
    *   粘贴 AI 的输出。
    *   点击“执行修改（调用二级 AI）”按钮。
6.  **并发执行和文件更新：** 应用会处理指令，并使用对 Gemini API 的并发 SDK 调用在内存中更新文件。
7.  **审查更改：** 在编辑器中查看更新后的文件。更改在内存中。

## 技术细节

*   **前端：** React (v19) 与 TypeScript，使用 Tailwind CSS 进行样式设计。
*   **AI 集成：**
    *   **一级（分析）：** 用户管理。
    *   **二级（修改）：** Google Gemini API，通过 `@google/genai` SDK。模型可配置（默认为 `gemini-2.5-flash-preview-04-17`）。
*   **环境变量（针对部署者）：**
    *   `API_KEY`: 部署者可以设置全局 API 密钥。
    *   `API_URL`: 部署者可以设置全局 API URL（但请参阅上面的 SDK 说明）。
*   **核心逻辑：** 内存中的文件系统表示、结构化文本解析、并发 API 调用。
*   **打包/服务：** 直接在 `index.html` 中通过导入映射表（import map）导入 ES 模块。

## 关键文件和结构

*   `index.html`, `index.tsx`, `App.tsx`
*   **`components/`**: `SettingsPanel.tsx`, `FileTreePanel.tsx`, `EditorPanel.tsx`, `Level1Panel.tsx`, `StatusBar.tsx`, `Button.tsx`
*   **`services/`**: `fileParserService.ts`, `geminiService.ts` (使用 `@google/genai` SDK)
*   `types.ts`, `constants.tsx`

## 如何运行

1.  **先决条件：** 支持 ES 模块和 `fetch` 的现代 Web 浏览器。
2.  **提供文件服务：** 使用本地 HTTP 服务器（例如 `npx serve .`、Python 的 `http.server`、VS Code Live Server）。
3.  **访问应用程序：** 打开本地 HTTP 服务器提供的地址（例如 `http://localhost:3000`）。
4.  **API 配置（设置面板）：**
    *   输入您的 **Gemini API 密钥**或依赖部署者设置的密钥。
    *   如果由部署者设置，**Gemini API URL** 字段可能会被隐藏。如果可见，您可以自定义它，但请注意 SDK 的行为。
    *   确认/设置 **Gemini 模型名称**。

## 重要注意事项

*   **API 密钥安全：** 用户输入的密钥存储在浏览器状态中。如果用户字段为空，部署者密钥（通过环境变量）不会直接暴露给最终用户的浏览器界面。
*   **一级 AI 输出格式：** 一级 AI 严格遵守指定的输出格式至关重要。
*   **CORS 问题与 SDK：** `@google/genai` SDK 负责与 Google 服务器的通信。如果您之前使用自定义代理 URL 来绕过手动 `fetch` 调用的 CORS 问题，则此代理可能与 SDK 的直接通信不兼容，除非它透明地代理官方 Google API 端点。正确使用 SDK 本身通常不需要特殊的 CORS 处理。
*   **内存操作：** 所有文件上传和修改当前都在浏览器会话的内存中处理。刷新页面将清除状态。没有内置功能可将修改后的文件保存回本地磁盘。
*   **环境变量暴露：** 如果进行部署，并希望部署者配置生效，请确保 `API_KEY` 和 `API_URL` 环境变量已正确暴露给应用程序的构建或运行时。对于 Vercel 静态部署，这通常涉及前缀（例如 `NEXT_PUBLIC_`）或其他构建时注入方法，这些超出了此简单应用结构的范围。本应用尝试读取 `process.env.API_KEY` 和 `process.env.API_URL`；如果这些在浏览器中未定义，则该功能将静默地不起作用。

## 未来增强（潜在想法）

*   直接“保存到磁盘”或“下载项目”功能。
*   与 Git 集成以进行版本控制。
*   更复杂的 API 调用错误恢复和重试机制。
*   在应用更改前可视化差异的 UI。
*   用户可配置的二级提示模板。
